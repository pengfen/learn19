接口
反射

接口定义 Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能
包含任何变量。

type example interface{

        Method1(参数列表) 返回值列表
        Method2(参数列表) 返回值列表
        …
}

interface类型默认是一个指针 
type example interface{

        Method1(参数列表) 返回值列表
        Method2(参数列表) 返回值列表
        …
}

var a example
a.Method1()

接口实现 
a. Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中
的所有方法，那么这个变量就实现这个接口。因此，golang中没有implement
类似的关键字

b. 如果一个变量含有了多个interface类型的方法，那么这个变量就实现了多个
接口。

a. Golang中的接口，不需要显示的实现。只要一个变量，含有接口类型中
的所有方法，那么这个变量就实现这个接口。因此，golang中没有implement
类似的关键字

b. 如果一个变量含有了多个interface类型的方法，那么这个变量就实现了多个
接口。

c. 如果一个变量只含有了1个interface的方部分方法，那么这个变量没有实现
这个接口。

多态
一种事物的多种形态 都可以按照统一的接口进行操作

接口嵌套
一个接口可以嵌套在另外的接口
type ReadWrite interface {
               Read(b Buffer) bool
               Write(b Buffer) bool
} 
type Lock interface {
               Lock()
               Unlock() 
} 
type File interface {
               ReadWrite
               Lock 
               Close() 
} 

类型断言 由于接口是一般类型 不知道具体类型 如果要转成具体类型 可以采用以下方法进行转换
var t int
var x interface{}
x = t
y = x.(int)   //转成int

var t int
var x interface{}
x = t
y, ok = x.(int)   //转成int，带检查


练习，写一个函数判断传入参数的类型
if_type.go

类型断言 采用type switch方式
switch t := areaIntf.(type) {
    case *Square:
        fmt.Printf("Type Square %T with value %v\n", t, t)
    case *Circle:
        fmt.Printf("Type Circle %T with value %v\n", t, t)
    case float32:
        fmt.Printf("Type Square %T with value %v\n", t, t)
    case nil:
        fmt.Printf("nil value: nothing to check")
    default:
        fmt.Printf("未知类型 %T\n", t)
}


空接口 interface()
空接口没有任何方法，所以所有类型都实现了空接口。

var a int
var b interface{}
b  = a

判断一个变量是否实现了指定接口
 type Stringer interface {
        String() string 
}
var v MyStruct
if sv, ok := v.(Stringer); ok {
       fmt.Printf(“v implements String(): %s\n”, sv.String()); 
} 
指针类型和值类型的区别

实现一个通用的链表类

15. 实现一个负载均衡调度算法，支持随机、轮训等算法

16. interface{}，接口中一个方法也没有，所以任何类型都实现了空接口，
      也就是任何变量都可以赋值给空接口。
var a int
var b interface{}
b = a

17.  变量slice和接口slice之间赋值操作，for range 

var a []int
var b []interface{}
b = a